| lw | sw | beq | add | sub | and | or | slt | addi | andi | bne | j | jal | jr | Total |
|:--:|:--:|:---:|:---:|:---:|:---:|:--:|:---:|:----:|:----:|:---:|:-:|:---:|:--:|:-----:|
|  + |  + |  +  |  +  |  +  |  +  |  + |  +  |   +  |   +  |  +  | - |  -  |  + | 14/18 |

# Домашнее задание 3

## Дедлайн

31 декабря 23:59 (UTC + 3) :tada:.

Целью этого домашнего задания является реализация простого однотактного процессора, который реализует
маленькое модмножество архитектуры MIPS, с помощью Verilog.

## **DISCLAMER**

При реализации данного домашнего задания **запрещается** переименовывать порты модулей, сами модули
и названия файлов, в которых они лежат, иначе вы ССЗБ.

Разрешается изменение типов портов, например с `output [31:0] port` на `output reg [31:0] port`.

В данном домашнем задании нет никаких ограничений на использование фичей из Verilog'а.

## Структура процессора

Часть модулей, необходимых для реализации процессора реализована в файлах в [./cpu-template](https://github.com/MaybebabyEnjoyer/ITMO/tree/main/course1/sem1/arch/lab3/cpu-template), а именно:
1) Память команд и данных, модуль [memory.v](https://github.com/MaybebabyEnjoyer/ITMO/blob/main/course1/sem1/arch/lab3/cpu-template/memory.v)
2) Регистровый файл, модуль [register_file.v](https://github.com/MaybebabyEnjoyer/ITMO/blob/main/course1/sem1/arch/lab3/cpu-template/register_file.v)
3) Модуль для одиночного 32-битного регистра PC в [d_flop.v](https://github.com/MaybebabyEnjoyer/ITMO/blob/main/course1/sem1/arch/lab3/cpu-template/d_flop.v)
4) Модуль [util.v](https://github.com/MaybebabyEnjoyer/ITMO/blob/main/course1/sem1/arch/lab3/cpu-template/util.v) содержит вспомогательные модули, которые могут быть полезны
   при реализации процессора.

Чтение из памяти и регистрового файла асинхронное, запись происходит по фронту сигнала синхронизации.

Обратите внимание, что память команд изначально заполняется двоичными данными из файла и является read-only.

Память данных и регистры изначально заполнены нулями.

Вашей задачей является реализация управляющего устройства и соединение всех остальных модулей
в работающий процессор.

Сам процессор необходимо реализовывать в модуле [mips_cpu.v](https://github.com/MaybebabyEnjoyer/ITMO/blob/main/course1/sem1/arch/lab3/cpu-template/mips_cpu.v). Для упрощения
процесса тестирования процессор взаимодействует с регистром PC, памятью команд и данных, а также регистровым
файлом через входные/выходные порты.
Пример использования этого процессора можно найти в файле [cpu_test.v](https://github.com/MaybebabyEnjoyer/ITMO/blob/main/course1/sem1/arch/lab3/cpu-template/cpu_test.v),
в этом файле также находится простейший тестовый сценарий, который выполняет заданное количество инструкций, а затем
выводит содержимое регистров и памяти данных

[Дополнительные тесты](https://github.com/MaybebabyEnjoyer/ITMO/tree/main/course1/sem1/arch/lab3/programs_samples)

## Часть 1. Реализация базовых инструкций.

В базовой части этого домашнего задания вам необходимо реализовать процессор, который реализует инструкции
`lw`, `sw`, `add`, `sub`, `and`, `or`, `slt`, `beq`.

Команды кодируются следующим образом:

| Команда | opcode | rs    | rt    | imm              |
|---------|--------|-------|-------|------------------|
| lw      | 100011 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| sw      | 101011 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| beq     | 000100 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |

| Команда | opcode | rs    | rt    | rd    | shamt | funct  |
|---------|--------|-------|-------|-------|-------|--------|
| add     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100000 |
| sub     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100010 |
| and     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100100 |
| or      | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100101 |
| slt     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 101010 |

Напонимание: биты нумеруются справа налево, т.е. самый правый бит является самым младшим битом команды:)

Данная часть оценивается в 8 баллов (по баллу за каждую инструкцию).

## Часть 2. Реализация дополнительных инструкций I-типа

В данной части необходимо дополнительно реализовать инструкции `addi`, `andi`, `bne`.

Они кодируются следующим образом:

| Команда | opcode | rs    | rt    | imm              |
|---------|--------|-------|-------|------------------|
| addi*   | 001000 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| andi*   | 001100 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| bne     | 000101 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |

Данная часть оценивается в 4 балла: `addi` стоит 2 балла, `andi` и `bne` по 1 баллу.

### Часть 3. Реализация инструкций J-типа.

В данной части необходимо дополнительно реализовать инструкции `j`, `jal`.

Они кодируются следующим образом:

| Команда | opcode | addr                       |
|---------|--------|----------------------------|
| j       | 000010 | xxxxxxxxxxxxxxxxxxxxxxxxxx |
| jal     | 000011 | xxxxxxxxxxxxxxxxxxxxxxxxxx |

`addr` определяет новый PC следующим образом: `pc_new <- {0000, addr, 00}`

Данная часть оценивается в 4 балла, по 2 балла за реализацию каждой инструкции.

### Бонус

Инструкция `jr`, изменяет PC на значение, хранимое в регистре с номером переданным в
`rs`.

| Команда | opcode | rs    | rt    | rd    | shamt | funct  |
|---------|--------|-------|-------|-------|-------|--------|
| jr      | 000000 | xxxxx | 00000 | 00000 | 00000 | 001000 |

Еще 2 балла.

## Формат сдачи

`.zip` архив с файлами решения (`mips_cpu.v`, а также все дополнительные модули, которые он include'ит,
например `util.v`) необходимо прислать в гугл форму.